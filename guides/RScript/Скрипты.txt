В игре много информации хранится в dat-файлах. Основные файлы - это /CFG/Main.dat, /CFG/CacheData.dat, /CFG/Rus/Lang.dat. При запуске игры датники всех подключенных модов и датники игры соединяются вместе.

Как добавить скрипт в мод:
	Скомпилированный скрипт нужно положить в папку <папка мода>/DATA/Script
	С помощью БлокПара нужно сделать следующее:
		Прописать путь к скомпилированному скрипту в кэшдате:
			В (/CFG/CacheData.dat).Script нужно добавить параметр <название скрипта>=Mods\<путь к моду>\DATA\Script\<имя файла скомпилированного скрипта>.scr
		Прописать что-то (хз что, все так пишут) в мейне:
			В (/CFG/Main.dat).Data.Script нужно добавить параметр <название скрипта>=1,Script.<название скрипта>
		Прописать строки диалогов в ланге:
			В (/CFG/Rus/Lang.dat).Script.<название скрипта> нужно добавить параметры из текстового файла, создаваемого RScript'ом, вида <номер строки>=<строка>. Это делается с помощью кнопки `Add from txt`

Интерфейс RScript:
	Кнопки сверху:
		Создание, открытие и сохранение файла:
			New - создать новый файл
			Open - открыть
			Save - сохранить (при нажатом Ctrl - Сохранить как...)
		
		Компиляция скрипта:
			Build script
				Script name
					Имя скрипта. Такое же имя должно быть прописано в датниках, потому что компилятор заменяет "строки" на CT("Script.<название скрипта>.<номер диалога>")
				Out script
					Путь, куда будет сохранен скомпилированный скрипт
				Out text
					Путь, куда будет сохранен текстовый файл, содержащий "строки". Потом нужно будет добавить эти строки в ланг мода.
			
		Режимы курсора:
			Режим управления готовыми элементами скрипта
				ПКМ+перетаскивание - перемещение элементов или перемещение по холсту
				ЛКМ (от одного элемента к другому) - создание стрелочки
				Двойное нажатие на элементе - открытие окна редактирования элемента
			Режим управления полями
				Для создания текстовых полей
			Режим создания\удаления элементов
				ЛКМ на пустом месте - создание нового элемента
				ЛКМ на элементе - удаление элемента

Типы элементов:
	Star - звезда
		no kling дополнительно ставит фильтр, что в системе сейчас нет доминаторских кораблей и не летят атакующие откуда-то. Subspace это из КР1 пришло, систем с таким флагом нет. Constellation если больше 0 - номер сектора. Priority определяет в каком порядке будут применяться условия при инициализации скрипта. Система с наименьшим значением (наименьшее значение должно присутствовать не более одного раза, чтобы первая система определялась однозначно) проверяется первой. no come kling помимо прочего вообще блокирует смену владельца, даже если туда как-то попадут доминаторы/пираты.
		Star - опорная система(ы). Используется в основном при задании условий запуска ну и для обозначения локации.
		Имя звезды, которое будет использоваться в скрипте как переменная
		(???) Приоритет 
		Сектор
		Принадлежность звезды доминаторам
	Planet - планета
		Planet - опорная планета. Может вносить вклад в условия запуска, может иметь свой диалог, может создавать на старте скриптовые корабли, если не удалось подцепить уже существующие.
		Внутреннее имя планеты, которое будет использоваться в скрипте как переменная
		Раса планеты
		Кому принадлежит планета
		Экономика
		Форма правления
		Расстояние от звезды
		(???) Диалог, который добавится на этой планете
	Ship - корабль
		Ship - используется только в условиях. Т.е. если к системе прицеплены объекты Ship типа МЦ и ЦР, то скрипт запустится только в системе с МЦ и ЦР.
		Принадлежность корабля к сторонам конфликта
		Тип корабля
		(???) Количество
		Наличие оружия и захвата
		Скорость корабля
		Свобоное место в трюме корабля
		Сила корабля
		Игрок ли этот корабль
	Item - предмет
		Внутреннее имя предмета, которое будет использоваться в скрипте как переменная
		Item - скриптовый предмет. Если не пустой, то сгенерится на старте там, где указано (например, в локации, в магазине планеты или в трюме корабля). Если пустой - может быть заполнен позже скриптовыми функциями.
	Place - место в космосе
		Place - локация. Может быть привязана к разным объектам. В принципе, всегде можно обойтись без них, с помощью координатных функций.
	Group - группа кораблей
		Group - скриптовая группа кораблей (часто единственный корабль). Если в скрипте нет ни одной непустой группы, он завершается. Если в свойствах группы прописать участников - они подцепятся/сгенерятся на старте. Иначе надо будет заполнять группу самому (я предпочитаю именно этот способ).
	State - состояние корабля или группы кораблей
		State - состояние, в котором находится скриптовый корабль. Корабли одной группы могут находиться в разных состояниях. К стейту может быть прицеплен диалог (при отсутствии - выдается стандартный). Прицепленный к стейту код отвечает за смену стейтов, какие-то регулярно выполняемые действия, или за поведение корабля, если в свойствах стейта поведение не указано. Модели поведения:
			None - корабль просто ничего не далает.
			Move - корабль перемещается в указанную локацию (Place).
			Follow - корабль следует за кораблем из указанной скриптовой группы (если таковые есть в той же системе).
			Jump - прыжок в указанную систему (Star).
			Landing - посадка на указанную планету. Не помню точно, может ли садиться на базы.
			Во всех перечисленных объектом действия может служить только скриптовый объект. Это серьезное ограничение, бтв. Существует служебная переменная EndState, которая позволяет проверить, завершено ли выполнение приказа.
			Кроме того, есть модель поведения - Free. Корабль при этом действует по своему разумению.
	Ether - выводит заметку
		Тип заметки
		(???) Уникальный ID заметки 
		Текст заметки
		Три корабля, на которые будет наводиться камера при нажатии на заметку
		
	If - если. Выполнение продолжится дальше, если условие истинно
		Условие
		Тип элемента (Normal, Init, Global, DialogBegin)
	While - цикл пока. Выполнение продолжится дальше несколько раз, пока условие истинно
		Условие
		Тип элемента (Normal, Init, Global, DialogBegin)
	Operation (сокращенно Op) - блок операций. Выполняются все операции внутри этого блока, после чего выполнение скрипта продолжается дальше
		Код
		Тип элемента (Normal, Init, Global, DialogBegin)
	Variable - переменная
		Имя переменной
		Тип переменной
		Начальное значение переменной
		Глобальная ли это переменная

	Dialog - диалог
		Название диалога (строка)
	DialogMsg
		Название ответа (???)
		Текст ответа
	DialogAnswer
		Название ответа (влияет на поведение при нажатии)
		Текст ответа

Есть четыре разных типа исполнения кода:
	Global запускается когда игра смотрит, не пора ли запустить новый скрипт, а это взлет/посада и прыжки между системами. Turn Code запускается каждый ход. У скриптовых кораблей также есть State Code, который запускается каждый день и еще в некоторых случаях. Но держать скрипт активным вообще все время нереально. Да и в любом случае, скрипты мягко говоря не предназначены для работы с моддингом оборудования (хотя перечисленные функции с выставлением бонусов, в принципе, реализуемы). Для таких вещей по хорошему надо отдельный функционал пилить, но это если и будет, то не в ближайшее время.
	Turn code - выполняется каждый ход, если скрипт работает
	Init code - выполняется один раз при инициализации скрипта
	Global code - выполняется каждый ход, пока скрипт не запущен. При выполнении условий запускает скрипт функцией GRun();. 
	Dialog code - выполняется при заходе на любой диалог (планета/станция/корабль/мостик)
	State code - блоки, привязанные к состоянию. Выполняется каждый ход для каждого корабля, имеющего данный стейт. Корабль, для которого выполняется стейткод, можно получить из переменной CurShip
	
	Use code - ???
	Act code - ???
При срабатывании какого-то из этих типов кода выполняются все элементы этого типа, на которые не показывает стрелка.
После выполнения какого-либо блока следующими выполнятся блоки, на которые показывают стрелки из этого блока (порядок выбора кривой). Если исходящих стрелок нет - то выполнение этой ветви завершается.

Минимальный набор элементов для работающего скрипта это:
	Global Op
		Внутри: `GRun();`
	Ship -> Star <- Planet <- Group -> State
		В Ship нужно поставить галочку `(v) Player`
		В Group нужно напсиать в `Count ship (min,max)` `1,1` и поставить галочку `(v) Add Player`


Особенности RScript'а:
	Пустая строка в конце блока Op вызывает ошибку (в конец можно написать `//`, тогда все будет ок)
	В `Init state` переменных можно писать выражение, содержащее функции
	Циклы из блоков Op запрещены (но можно заменить один Op на Ether, тогда компилятор либо проигнорирует цикл, либо крашнет со `stack overflow`)
	В If можно вставить код (но так лучше не делать): 
		`1) {<код дня исполнения>}; if(<условие>` - в этом случае выполнится код, потом проверится условие, и в зависимости от него исполнение продолжится (или не продолжится)

Особенности дабоязыка:
	#комментарий, нет, не комментарий, а херня какая-то
	'str' - такие строки не выносятся в ланг. Так лучше писать теги, имена разделов и константные строки типа ' III'
	"str" - такие строки выносятся в ланг. Так лучше писать диалоговые строки и названия на русском языке.
	`result=a` вместо `return a`
	Нет типа `bool`, условия срабатывают, когда выражение не 0 или не пусто.
	Нет `i++` и `i+=1` (и аналогичных), нужно писать `i=i+1`
	Тип выражения определяется по типу первого значения (но вычисляется видимо по-нормальному, преобразование типа происходит в конце вычисления):
		1.5 + 1 	-> 2.5
		1 + 1.5 	-> 2
		1.5 * 3 	-> 4.5
		3 * 1.5 	-> 4
		1 + 'abc' 	-> 1
		'abc' + 1 	-> 'abc1'
		'' + 1 		-> '1'
	В этом нет логики, но это так:
		'b'-'a' 	-> 'ba'
		'a'*2 		-> 'a2'
		'a'/0 		-> 'a0'
		'a'/'b' 	-> 'ab'
		0 == 'a'    -> 1
	Типы:
		unknown (обычно для массивов)
		int
		dword
		str
		float
		array ?

if(cond){}
if(cond){}else{}
for(init;cond;inc){}
while(cond){}
function sum(x, y){result = x + y;}
result - переменная для возврата значения

exit - завершает выполнение функции
continue - завершает текущую итерацию цикла
break - завершает цикл
throw expr - вызывает краш, пишет в лог expr

Функции для работы с объектами:
	new
	delete
	copy

Арифметические операции: + - * / %
Операции сравнения: == != > >= < <=
Логические операции: && ||
Битовые операции: & << >>

Rnd(a, b) - не меняется при перезагрузке
rnd(a, b) - меняется при перезагрузке
randomize() - меняет зерно rnd
randseed([newseed]) - меняет или возвращает зерно rnd

Числовые функции:
	round int frac
	abs min max
	sqr sqrt
	pi sin cos arctan
	exp ln

Функции для работы со строками:
	count
	trim
	substr
	findsubstr
	lowercase
	uppercase
	ord
	toansi
	tounicode
